---
interface Props {
  interval?: number;
}

const { interval = 8000 } = Astro.props as Props;
---

<div
  class="relative px-0 max-w-[550px] lg:max-w-[700px] xl:max-w-[900px] w-auto hero-carousel flex flex-col justify-center items-center gap-[27px]"
  data-interval={interval}
>
  <!-- Viewport -->
  <div class="overflow-hidden w-full h-full">
    <div
      class="flex transition-transform duration-800 ease-in-out review-track hero-carousel-track h-full"
      id="carousel-track"
    >
      {
        Array.from({ length: 4 }, (_, i) => (
          <div class="shrink-0 w-full md:w-[60%] h-full px-0 md:px-2.5">
            <img
              src={`/images/main/slide-${i + 1}.webp`}
              alt="Slide image"
              width="520"
              height="294"
              class="w-full h-full object-cover "
              loading="lazy"
              decoding="async"
            />
          </div>
        ))
      }
    </div>
  </div>
  <!-- Controles con barra de progreso y botones -->
  <div class="w-full flex justify-start items-center gap-12 px-1">
    <div class="w-full md:w-[60%] flex items-center gap-4">
      <div class="flex-1 bg-[#E8E8E8] md:bg-white/50 rounded-full h-[5px] md:h-1 backdrop-blur-sm">
        <div
          class="hero-carousel-progress bg-[#926412] md:bg-white h-1 rounded-full transition-all duration-500 ease-out"
          style="width: 0%"
        >
        </div>
      </div>
    </div>

    <!-- Botón anterior -->
    <div class="md:flex justify-center items-center gap-3.5 hidden">
      <button
        class="hero-carousel-prev border border-white text-white py-4 px-4 rounded-full transition-all duration-200 cursor-pointer hover:bg-white hover:text-primary"
        aria-label="Previous slide"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M15 19l-7-7 7-7"></path>
        </svg>
      </button>

      <!-- Botón siguiente -->
      <button
        class="hero-carousel-next border border-white text-white py-4 px-4 rounded-full transition-all duration-200 cursor-pointer hover:bg-white hover:text-primary"
        aria-label="Next slide"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9 5l7 7-7 7"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<style>
  .hero-carousel-progress {
    /* default: use brand brown on small screens */
    background: #926412 !important;
    box-shadow: 0 0 8px rgba(0, 0, 0, 0.15) !important;
  }
  @media (min-width: 768px) {
    .hero-carousel-progress {
      /* desktop: white progress as before */
      background: linear-gradient(90deg, white 0%, white 100%) !important;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3) !important;
    }
  }
</style>

<script is:inline>
  (function () {
    if (typeof window === 'undefined') return;

    // Función simple para generar un hash (para IDs únicos)
    String.prototype.hashCode = function () {
      let hash = 0;
      for (let i = 0; i < this.length; i++) {
        const char = this.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    };

    const debounce = (fn, ms = 100) => {
      let t;
      return (...a) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, a), ms);
      };
    };

    function initCarousel(carousel) {
      if (!carousel || carousel.dataset.inited) return;
      carousel.dataset.inited = '1';

      const track = carousel.querySelector('.hero-carousel-track');
      const prevBtn = carousel.querySelector('.hero-carousel-prev');
      const nextBtn = carousel.querySelector('.hero-carousel-next');
      const progressBar = carousel.querySelector('.hero-carousel-progress');
      const counter = carousel.querySelector('.hero-carousel-counter');
      const total = carousel.querySelector('.hero-carousel-total');

      const intervalMs =
        parseInt(carousel.getAttribute('data-interval') || '0', 10) || 5000;

      let slides = Array.from(track.children);
      const totalSlides = slides.length;

      // Actualizar el contador total
      if (total && totalSlides > 0) {
        total.textContent = totalSlides.toString();
      }

      const setup = () => {
        // helper to detect items per view
        function getItemsPerView() {
          // Determine items per view by measuring container and first slide width.
          const containerW =
            track.getBoundingClientRect().width || window.innerWidth;
          const first = slides[0];
          if (!first) return 1;
          const slideW = first.getBoundingClientRect().width || containerW;
          const approx = Math.max(1, Math.round(containerW / slideW));
          return approx;
        }

        // clear any previous auto interval stored on the carousel (when re-running setup)
        if (carousel._heroAuto) {
          clearInterval(carousel._heroAuto);
          carousel._heroAuto = null;
        }

        // recompute responsive values
        let itemsPerView = getItemsPerView();
        let step = itemsPerView >= 4 ? 2 : itemsPerView;

        // Keep originals (non-clone) and remove previous clones
        const originals = Array.from(track.children).filter(
          (n) => !n.classList.contains('clone')
        );
        // remove any existing clones
        Array.from(track.querySelectorAll('.clone')).forEach((n) => n.remove());

        // If there is only one original slide, nothing to clone
        if (originals.length <= 1) {
          slides = Array.from(track.children);
        } else {
          const cloneCount = itemsPerView;

          // prepend clones of the last `cloneCount` originals
          for (
            let i = Math.max(0, originals.length - cloneCount);
            i < originals.length;
            i++
          ) {
            const c = originals[i].cloneNode(true);
            c.classList.add('clone');
            track.insertBefore(c, track.firstChild);
          }

          // append clones of the first `cloneCount` originals
          for (let i = 0; i < Math.min(cloneCount, originals.length); i++) {
            const c = originals[i].cloneNode(true);
            c.classList.add('clone');
            track.appendChild(c);
          }

          slides = Array.from(track.children);
        }

        let currentIndex = itemsPerView; // start at first real slide after prepended clones
        let isTransitioning = false;
        let autoSlide;

        // itemsPerView and step are declared above and updated in updateProgress when needed

        function getSlideWidth() {
          return slides[0].getBoundingClientRect().width;
        }

        function updateProgress() {
          if (slides.length <= 1) return;

          // realSlideCount is the number of original slides (without clones)
          const realSlideCount = Array.from(track.children).filter(
            (n) => !n.classList.contains('clone')
          ).length;

          // Recompute itemsPerView and step in case of resize
          itemsPerView = getItemsPerView();
          step = itemsPerView >= 4 ? 2 : itemsPerView;

          // Compute realIndex (0-based in originals)
          const cloneCount = itemsPerView;
          let realIndex =
            (currentIndex - cloneCount + realSlideCount) % realSlideCount;

          // Use exact slide index for progress so the bar updates per slide (1..N)
          const progressPercentage = ((realIndex + 1) / realSlideCount) * 100;

          if (progressBar) {
            progressBar.style.width = `${progressPercentage}%`;
          }

          if (counter) {
            counter.textContent = (realIndex + 1).toString();
          }
        }

        function goTo(index, smooth = true) {
          if (slides.length <= 1) return;

          const maxIndex = slides.length - 1;
          if (index < 0) index = 0;
          if (index > maxIndex) index = maxIndex;

          if (isTransitioning && smooth) return;
          track.style.transition = smooth
            ? 'transform 0.5s ease-in-out'
            : 'none';
          track.style.transform = `translateX(-${getSlideWidth() * index}px)`;
          currentIndex = index;
          isTransitioning = smooth;
          updateProgress();
        }

        if (slides.length > 1) {
          track.addEventListener('transitionend', () => {
            const originalsCount = Array.from(track.children).filter(
              (n) => !n.classList.contains('clone')
            ).length;
            const cloneCount = itemsPerView;

            // if we've moved into the clones at the end, jump back to the equivalent original
            if (currentIndex >= originalsCount + cloneCount) {
              currentIndex = currentIndex - originalsCount;
              track.style.transition = 'none';
              track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
            }

            // if we've moved into the clones at the start, jump forward to equivalent original
            if (currentIndex < cloneCount) {
              currentIndex = currentIndex + originalsCount;
              track.style.transition = 'none';
              track.style.transform = `translateX(-${getSlideWidth() * currentIndex}px)`;
            }

            isTransitioning = false;
          });
        }

        prevBtn?.addEventListener('click', () => {
          // move by one slide on button press
          goTo(currentIndex - 1);
          resetAuto();
        });

        nextBtn?.addEventListener('click', () => {
          // move by one slide on button press
          goTo(currentIndex + 1);
          resetAuto();
        });

        function startAuto() {
          if (slides.length > 1) {
            // auto-advance by one slide each interval
            carousel._heroAuto = setInterval(
              () => goTo(currentIndex + 1),
              intervalMs
            );
          }
        }

        function stopAuto() {
          if (carousel._heroAuto) {
            clearInterval(carousel._heroAuto);
            carousel._heroAuto = null;
          }
        }

        function resetAuto() {
          stopAuto();
          startAuto();
        }

        carousel.addEventListener('mouseenter', stopAuto, { passive: true });
        carousel.addEventListener('mouseleave', startAuto, { passive: true });

        // Touch support
        let startX = 0,
          deltaX = 0;

        track.addEventListener(
          'touchstart',
          (e) => {
            startX = e.touches[0].clientX;
            stopAuto();
          },
          { passive: true }
        );

        track.addEventListener(
          'touchend',
          (e) => {
            deltaX = e.changedTouches[0].clientX - startX;
            if (Math.abs(deltaX) > 50) {
              const dir = deltaX < 0 ? 1 : -1;
              // move one slide per swipe
              goTo(currentIndex + dir);
            }
            resetAuto();
          },
          { passive: true }
        );

        // Mouse drag support
        let isDragging = false;
        let dragStartX = 0;
        let dragDelta = 0;

        function onMouseMove(e) {
          if (!isDragging) return;
          dragDelta = e.clientX - dragStartX;
          const translate = -getSlideWidth() * currentIndex + dragDelta;
          track.style.transform = `translateX(${translate}px)`;
        }

        function onMouseUp() {
          if (!isDragging) return;
          isDragging = false;
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
          if (Math.abs(dragDelta) > 50) {
            const dir = dragDelta < 0 ? 1 : -1;
            // move one slide per drag
            goTo(currentIndex + dir);
          } else {
            goTo(currentIndex, true);
          }
          dragDelta = 0;
          resetAuto();
        }

        track.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;
          isDragging = true;
          dragStartX = e.clientX;
          dragDelta = 0;
          stopAuto();
          track.style.transition = 'none';
          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
          e.preventDefault();
        });

        function init() {
          slides = Array.from(track.children);
          if (slides.length > 1) {
            goTo(currentIndex, false);
          }
          updateProgress();
        }

        // On resize re-run setup to rebuild clones for the new itemsPerView
        window.addEventListener(
          'resize',
          debounce(() => setup(), 120)
        );

        init();
        startAuto();
      };

      if ('requestIdleCallback' in window)
        requestIdleCallback(setup, { timeout: 1500 });
      else setTimeout(setup, 600);
    }

    const carousels = Array.from(
      document.querySelectorAll('.hero-carousel[data-interval]')
    );
    if (carousels.length === 0) return;

    if ('IntersectionObserver' in window) {
      const io = new IntersectionObserver(
        (entries, obs) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              initCarousel(entry.target);
              obs.unobserve(entry.target);
            }
          });
        },
        { root: null, rootMargin: '400px' }
      );
      carousels.forEach((c) => io.observe(c));
    } else {
      carousels.forEach((c) => initCarousel(c));
    }
  })();
</script>
